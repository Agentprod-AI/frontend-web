/* eslint-disable import/no-unresolved */
/* eslint-disable no-console */

"use client";
import React, { useEffect, useState } from "react";
import { Pencil, Eye } from "lucide-react";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import EditorContent from "./editor-content";
import PreviewContent from "./preview-content";

import {
  getAutogenerateTrainingEmail,
  startCampaign,
  getPreviewByTemplate,
  createTraining,
  TrainingRequest,
  updateTraining,
} from "./training.api";
import { useUserContext } from "@/context/user-context";
import { useRouter, useParams } from "next/navigation";
import { useAutoGenerate } from "@/context/auto-generate-mail";
import { useFieldsList } from "@/context/training-fields-provider";
import AutoAwesomeIcon from "@mui/icons-material/AutoAwesome";
import { LoadingCircle } from "@/app/icons";
import { toast } from "sonner";

export interface PreviewData {
  email: {
    subject: string;
    body: string;
  };
  contact?: any;
  linkedin_information?: string;
}
const loadingStates = [
  { text: "Converting Text" },
  { text: "Generating Preview" },
  { text: "Processing Data" },
  { text: "Finalizing" },
];

export default function Training() {
  const [activeTab, setActiveTab] = React.useState("editor");
  const [previewData, setPreviewData] = React.useState<PreviewData | null>(
    null
  );
  const { user } = useUserContext();
  const params = useParams<{ campaignId: string }>();
  const {
    setAutoGeneratedBody,
    setAutoGeneratedSubject,
    setContact,
    setLinkedinInformation,
    setPreviewType,
    previewType,
  } = useAutoGenerate();
  const { fieldsList, body, subject, followUp, subjectOptions } =
    useFieldsList();
  const router = useRouter();
  const [startCampaignIsLoading, setStartCampaignIsLoading] =
    React.useState(false);

  // useEffect(() => {
  //   if (previewData && activeTab === "preview") {
  //     // If preview data is available and tab is switched to preview, fetch preview content
  //     handleCustomGenerate();
  //   }
  // }, []);

  const handleGenerateWithAI = async () => {
    try {
      const response = await getAutogenerateTrainingEmail(
        params.campaignId,
        user.id
      );
      console.log(response);
      const { email, contact, linkedin_information } = response;

      setPreviewData({ email, contact, linkedin_information });
      setActiveTab("preview");
    } catch (error) {
      console.error("Failed to fetch training data:", error);
    }
  };

  const handleStartCampaign = async () => {
    setStartCampaignIsLoading(true);
    const userId = user.id as string;

    try {
      toast.success(
        "Your drafts are getting created, it might take some time."
      );
      if (previewType === "previewFromTemplate") {
        const response = await startCampaign(
          params.campaignId,
          userId,
          "False"
        );
        console.log("trainingResponse", response);
      } else if (previewType === "previewFromAI") {
        const response = await startCampaign(params.campaignId, userId, "True");
        console.log("trainingResponse", response);
      }

      setStartCampaignIsLoading(false);
      router.push("/dashboard/mail");
    } catch (error: any) {
      console.log("TrainingResponse", error);
      toast.error(error.message);
      setStartCampaignIsLoading(false);
    }
  };

  const handleCustomGenerate = async () => {
    try {
      const trainingBody = {
        campaign_id: params.campaignId,
        template: `Subject: ${subject}\n\n${body}`,
        follow_up_template: followUp,
        variables: fieldsList.variables.reduce<Record<string, string>>(
          (acc, field) => {
            acc[field.id] = field.value;
            return acc;
          },
          {}
        ),
        offering_variables: fieldsList.offering_variables.reduce<
          Record<string, string>
        >((acc, field) => {
          acc[field.fieldName] = field.description;
          return acc;
        }, {}),
        personalized_fields: fieldsList.personalized_fields.reduce<
          Record<string, string>
        >((acc, field) => {
          acc[field.fieldName] = field.description;
          return acc;
        }, {}),
        enriched_fields: fieldsList.enriched_fields.map(
          (field) => field.fieldName
        ),
        subject_field_options: subjectOptions,
      };

      console.log(trainingBody);
      // await createTraining(trainingBody as TrainingRequest);

      await updateTraining(user.id, trainingBody);

      const response = await getPreviewByTemplate({
        campaign_id: params.campaignId,
        user_id: user.id,
        template: `Subject: ${subject}\nBody: ${body}`,
        variables: fieldsList.variables,
        offering_variables: fieldsList.offering_variables,
        personalized_fields: fieldsList.personalized_fields,
        enriched_fields: fieldsList.enriched_fields,
      });
      console.log("response from api " + response.email);

      setPreviewData({
        email: {
          body: response.body,
          subject: response.subject,
        },
      });

      console.log("response from get email by template", response);
      setAutoGeneratedBody(response.email.body);
      setAutoGeneratedSubject(response.email.subject);
      setContact(response.contact);
      setLinkedinInformation(response.linkedin_information);
      setPreviewType("previewFromTemplate");
      toast.success("Preview Generated");
    } catch (error) {
      console.error("Failed to fetch training data:", error);

      // Handle error gracefully, maybe set some state or log the error.
    }
  };

  const handleLetAiWrite = async () => {
    toast.success("AI is writing your email, it might take some time.");
    try {
      const response = await getAutogenerateTrainingEmail(
        params.campaignId,
        user.id
      );
      setPreviewData({
        email: {
          body: response.body,
          subject: response.subject,
        },
      });
      console.log(response.body);
      setAutoGeneratedBody(response.email.body);
      setAutoGeneratedSubject(response.email.subject);
      setContact(response.contact);
      setLinkedinInformation(response.linkedin_information);
      setPreviewType("previewFromAI");
      console.log("response from training page", response);
      setActiveTab("preview");
    } catch (error) {
      console.error("Failed to fetch training data:", error);
    }
  };

  const onTabChange = (tab: string) => {
    setActiveTab(tab);
  };

  return (
    <>
      <div className="w-full h-14 px-4 flex flex-row justify-between items-center rounded-lg border">
        <div className="ml-4">Training</div>
        <div className="flex items-center flex-row">
          <Tabs
            value={activeTab}
            onValueChange={onTabChange}
            className="w-[200px]"
          >
            <TabsList>
              <TabsTrigger value="editor" className="flex gap-1">
                <Pencil className="h-3 w-3" />
                Editor
              </TabsTrigger>
              <TabsTrigger
                value="preview"
                className="flex gap-1"
                onClick={handleCustomGenerate}
              >
                <Eye className="h-3 w-3" />
                Preview
              </TabsTrigger>
            </TabsList>
          </Tabs>
          {startCampaignIsLoading ? (
            <LoadingCircle />
          ) : (
            <Button onClick={handleStartCampaign}>Start campaign</Button>
          )}
        </div>
      </div>
      {activeTab === "editor" ? (
        <div>
          <div
            className="mx-16 mt-3 hover:underline cursor-pointer"
            onClick={handleLetAiWrite}
          >
            Let AI write email on its own <AutoAwesomeIcon />
          </div>
          <EditorContent />
        </div>
      ) : (
        <PreviewContent />
      )}
    </>
  );
}
